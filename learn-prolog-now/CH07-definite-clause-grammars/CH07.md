# Chapter 7: Definite Clause Grammars

## 7.1 Context Free Grammars

**Grammar**

**Contexte free language** Are languages that can be generated by context free grammars.
**Context Free Grammars:** are a finite collection of rules which tell us that certain sentences are grammatical. and what their grammatical structure actually is.

s  ->  np  vp

np  ->  det  n

vp  ->  v  np

vp  ->  v

det  -> a

det  -> the

n  -> woman

n  -> man

v  -> shoots

**->** defines a rule  and is read as 'can be built of'
** non-terminal symbols:** s, np, vp det, n , v
** Terminal symbols:** the, woman, shoots, man, 
** context free rules:** each of the lines above
**parse tree:** Give information about strings, give information baout structure
**recognizer** Only tells whether yes or no a sentence is grammatical but says nothing about the structure of said sentence.

How to write a recognizer given a context free grammar?
First we will build a naive version
Then build a better version using difference lists


**Difference Lists** REpresents the information about grammatical categories as the difference between two lists.

[a,woman,shoots,a,man] -> [a,woman,shoots,a,man] []

**The first list** = What needs to be consumed (the input list)
**The second list** = What needs to be left behind(the output list)
If I consume all the symbols on the left, and leave behind the symbols on the right, then I have the sentence I am interested in.


## 7.2 Definite Clause Grammars

**Definite Clause Grammars** Are a way of writing grammars that hides the difference list variables.

s  -->  np  vp

np  -->  det  n

vp  -->  v  np

vp  -->  v

det  --> a

det --> the

n  --> woman

n  --> man

v  --> shoots


this gets translated into prolog code

ask question 
s([the,woman,shoots,the,man],[]).

can add recursion by adding something like

s --> s,conj,s 

**Problems:**
1. problem is that if we put it before the non-recursive part we get into a loop
2. if we put it after the recursive part, then it gets into a loop when it encounters a non grammatical sentence.

**Solution:**
Introduce a new non-terminal symbole and rewrite the dcg
   s  -->  simple_s.
   simple_s  -->  np,vp.
   s  -->  simple_s,conj,s.

The moral is: DCGs aren’t magic. They are a nice notation, but you can’t expect to write down an arbitrary CFG as a DCG and have it run without problems. DCG rules are ordinary Prolog rules in disguise, and this means that you must pay attention to what your Prolog interpreter is going to do with them. And in particular, you have to keep an eye out for left-recursion.
n terms of context-free grammar, a nonterminal is left-recursive if the leftmost symbol in one of its productions is itself (in the case of direct left recursion) or can be made itself by some sequence of substitutions (in the case of indirect left recursion).


## DCG for a simple formal language**

```
s  -->  [].
s  -->  l,s,r.

l  -->  [a].
r  -->  [b].
```